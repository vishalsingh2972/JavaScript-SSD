<!DOCTYPE html>
<html>

  <head>
    <title>Advanced Functions2</title>
  </head>

  <body>
    <button onclick="
      console.log('click using onclick')">Click1</button>

    <!--.addEventListener()-->
    <button onclick="" class="js-button">Click2</button>
    <!--<button class="js-button">Click2</button>-->

    <script>
/*
      const buttonElement = document.querySelector('.js-button');
      //every JTML element has a method called .addEventListener, addEventListener lets us run some code when we interact with the element //it sort of does the same thing that onclick is doing

      buttonElement.addEventListener('click', () => {
        console.log('click using addEventListener');
      }); //() takes 2 parameters- first parameter is the event or what type of interaction we want and second parameter is a function that we want to run when we click this element 
      //this does same thing as onclick in Click1, however addEventListener has some advantages over using an attribute like onclick
      //advanatages
      //1)addEventListener lets us add multiple event listeners for an event
      buttonElement.addEventListener('click', () => {
        console.log('click using addEventListener2');
      }); 
      //2)we can remove an event listener using .removeEventListener()
      const eventListener = () => {
        console.log('click using addEventListener3');
      };
      buttonElement.addEventListener('click', eventListener); 
      buttonElement.removeEventListener('click', eventListener);
//Best Practice: Use .addEventListener() instead of onclick="..." attribute
*/

//Arrow Functions - a shorter way to write functions
/*
      const arrowFunction = (param, param2) => {
        console.log('hello');
        return 5;
      };
  //above is an arrow function that works same as a regular function (as given below)- 

    //this is a regular function just name of variable given as arrowFunction for easy comparison
      // const arrowFunction = function(param, param2){ 
      //   console.log('hello');
      //   return 5;
      // }; 

      arrowFunction();
      //console.log(arrowFunction()); //to get return value
      //console.log(arrowFunction); 
      
  //DIFFERENCES between Arrow Functions and Regular Functions

    //Arrow Functions have a few shortcuts that regular functions don't have
      //Shortcut #1
      const oneParam = param => { //will work same as const oneParam = (param) => { because if we have only 1 parameter we can remove the brackets()
        console.log(param + 1);
      }
      oneParam(2);

      //Shortcut #2
      // const oneLine = () => {
      //   return 2 + 3;
      // }
    //if we have only one line inside {} we can put everything in one line/in the same line as the arrow =>
      //const oneLine = () => {return 2 + 3;}
    //and now that everything is on the same line the {} are optional an can be removed, and we can also remove the return statement as well
      const oneLine = () => 2 + 3; //so this is a one line arrow function //i.e here if we just have an arrow => it will automatically return the result present on the right side of the arrow => (i.e here 2 + 3 will be returned automatically)
      console.log(oneLine());

  //Practice trials using arrow functions

      // [
      //   'make dinner2',
      //   'wash bartan2',
      //   'watch youtube2'
      // ].forEach(function(value, index){ 

      //   if(value === 'wash bartan2'){
      //     return; //basically this does the same thing as continue in a for loop
      //   }
      //   console.log('bittu ' + value + ' ' + index);
      // }); 
    console.log('');
        //same above regular function using arrow function
      [
        'make dinner2',
        'wash bartan2',
        'watch youtube2'
      ].forEach((value, index) => { 

        if(value === 'wash bartan2'){
          return; //basically this does the same thing as continue in a for loop
        }
        console.log('bittu ' + value + ' ' + index);
      }); 
      //so when passing a function into another function (like above example) - it is recommended to use arrow functions instead of regular function beacuse it makes our code easier to read

  //Another place where we could use arrow functions which is inside an object
      const object2 = {
        method: () => { //arrow function

        },
        method() { //shorthand method syntax - easier to read than above arrow function, so when saving a function in an object it is recommended to use this syntax(shorthand method syntax) instead of above arrow function syntax
        }
      };
*/

//More features that use functions as values
  //we already learned the array method forEach that lets us loop through the elements of the array, now we will se 2 more array methods - .filter() and .map()

  //.filter() array method
    console.log([1, -3, 5].filter(function(value, index){
      return true;
    }));//using regular function

    console.log([1, -3, 5].filter((value, index) => {
      return true; //in this function inner function always returns true so all 3 values will be added in the new array
    }));//using arrow function
    //Basically what .filter() does here is 1) it creates a new array [] 2) if the inner function returns true it will put the value in the new array and if the inner function returns false it will not put the value in the new array

    console.log([1, -3, 5].filter((value, index) => {
      return false; //in this function inner function always returns false so all 3 values will not be added in the new array
    }));

    //we want to remove negative numbers from the array [1, -3, 5] ---> [1, 5]
    console.log([1, -3, 5].filter((value, index) => {
      if(value >= 0) {
        return true; //values included in new array
      } else {
      return false; //values NOT included in new array
      }
    }));
    //we can simple shorted this code as
    console.log([1, -3, 5].filter((value, index) => {
      return value >= 0; //this will return true if >= 0 and add in new array and will return false if <=0 and not add in new array
    })); 

  //.map() array method
    console.log([1, 1, 3].map((value, index) => {
      return 10; 
    }));
    //Same here also Basically what .map() does here is 1) it creates a new array [] 2) and whatever we return will be added to the new array

    console.log([1, 1, 3].map((value, index) => {
      return value + 10; 
    }));

    //return array where each element is doubled
    console.log([1, 1, 3].map((value, index) => {
      return 2 * value; 
    }));

  //Shortcuts of arrow functions (to make above code more compact)
    //#1
    console.log([1, 1, 3].map(value => { //index not being used inside function so removed so now arrow function has only 1 parameter so (value) => { can be written as value => {
      return 2 * value; 
    }));

    //#2
    console.log([1, 1, 3].map(value => { 
      return 2 * value; 
    }));
    //if we have only 1 line of code in an arrow function, we can put the code on 1 line like this
//    console.log([1, 1, 3].map(value => { return 
//      2 * value;}));
    //and now the {} and return are also optional and can be removed as well
    console.log([1, 1, 3].map(value => 2 * value)); //does same work as above code but looks super compact and clean 

//Closure - if a function has access to a value, it will always have access to that value
 //example in 12-3 todo-list.js




    </script>
  </body>

</html>